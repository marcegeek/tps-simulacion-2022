\begin{abstract}
Los números pseudoaleatorios se generan de manera secuencial con un algoritmo determinístico. Construir un buen algoritmo de números pseudoaleatorios es complicado, por eso hemos hecho un estudio sobre cómo funcionan y de la manera que se comportan.
\end{abstract}


% keywords can be removed
%\keywords{First keyword \and Second keyword \and More}


\section{Introducción}
Los números aleatorios son muy útiles en distintos ámbitos de aplicación, como pueden ser la simulación, el muestreo, el análisis numérico, la programación de computadoras en general, la toma de decisiones, la estética y la recreación \cite{knuth1997seminumerical}. En nuestro caso, resulta particularmente importante su aplicación al campo de la simulación.

Hace muchísimos años, las personas que necesitaban números aleatorios en sus trabajos científicos tenían que recurrir a fuentes ``convencionales'' de aleatoriedad (bolilleros, dados, cartas, entre otras) \cite{knuth1997seminumerical}. Más tarde se publicaron tablas, como la publicada en 1927 por H. L. C. Tippett, de 40000 dígitos. Posteriormente surgieron dispositivos que generaban números aleatorios de manera mecánica. La computadora Ferranti Mark I, instalada por primera vez en 1951, tenía una instrucción que obtenía 20 bits aleatorios usando el ruido de una resistencia eléctrica. En 1955 la RAND Corporation publicó una ampliamente usada tabla de un millón de dígitos aleatorios obtenidos con la ayuda de otro dispositivo especial. Una famosa máquina de números aleatorios llamada ERNIE (el primer modelo, construido en 1956 \cite{virtualernie}) fue utilizada por muchos años (desde 1957 hasta 1973 \cite{virtualernie}) para seleccionar los números ganadores de la lotería de bonos \emph{Premium Savings Bonds} británica. Esta última fue luego reemplazada por sucesivas versiones, siendo la quinta la más reciente, de 2019, que funciona con tecnología cuántica, empleando luz en lugar de ruido térmico como las anteriores \cite{virtualernie}. Hoy en día otro generador de números aleatorios reales y de acceso al público en general es el servicio de RANDOM.ORG, que se basa el procesamiento de ruido atmosférico captado mediante un arreglo de receptores de radio \cite{randomorgfaq}.

Con la introducción de las computadoras, se comenzó a buscar maneras eficientes de generar números aleatorios dentro de los programas \cite{knuth1997seminumerical}. Las tablas no eran prácticas porque tenían un tamaño finito, requerían memoria y tiempo para cargarlas, además de que había que mantenerlas.\footnote{Los avances tecnológicos desde la década de 1990 hasta la actualidad las han hecho nuevamente útiles, debido a la posibilidad de almacenar, transportar y transmitir grandes volúmenes de datos con facilidad \cite{knuth1997seminumerical}.} Las máquinas como ERNIE podían servir, pero dificultaban probar el software, debido a la no repetibilidad de sus resultados; por otro lado, esa clase de máquinas tendían a sufrir de malfunciones muy difíciles de detectar \cite{knuth1997seminumerical}.

Fue esta insuficiencia de los métodos mecánicos en los primeros días lo que llevó a un interés en producir números aleatorios empleando las operaciones aritméticas ordinarias de una computadora. John von Neumann sugirió por primera vez este enfoque alrededor de 1946, ideando el método de los cuadrados medios, que luego analizaremos en mayor detalle \cite{knuth1997seminumerical}.

Estos métodos, que parecen generar números aleatorios, pero no lo hacen realmente, se denominan \emph{pseudoaleatorios} o \emph{cuasialeatorios} \cite{knuth1997seminumerical}. Existen diferentes tipos y familias de generadores números pseudoaleatorios, algunos de ellos son el método de los cuadrados medios y los generadores congruenciales lineales (GCL) (y los generadores congruenciales en general). En nuestro estudio nos enfocaremos en el método de los cuadrados medios y los GCL.

\section{Descripción del trabajo}
    Utilizando en Python 3.7, reproducimos y comparamos algoritmos generadores de números pseudoaleatorios, poniendo a prueba
    la aleatoriedad de cada método por medio de diferentes pruebas.

    Los algoritmos generadores de números pseudoaleatorios utilizados fueron:
\begin{enumerate}
    \item Método de los cuadrados medios, en dos variantes:
      \begin{enumerate}
        \item 4 dígitos
        \item 10 dígitos (aproximadamente 34 bits como máximo, que da un rango similar a los GCL estudiados)
      \end{enumerate}
    \item Generador congruencial lineal (GCL), en sus formas:
    \begin{enumerate}
        \item Parámetros de glibc ($m=2^{31},a=1103515245,c=12345$)
        \item Parámetros arbitrarios ($m=2^{31},a=1000,c=151$)
    \end{enumerate}
    \item Generador del módulo \texttt{random}  de Python (generador Mersenne Twister (MT19937)
\end{enumerate}
    Y las pruebas realizadas, fueron:
\begin{enumerate}
    \item Test de $\chi^{2}$
    \item Test de póker
    \item Test de rachas
    \item Test de frecuencia (monobit)
\end{enumerate}


\section{Marco teórico}
Existen diferentes tipos y familias de generadores de números pseudoaleatorios, algunos de ellos son el método de los cuadrados medios y los generadores congruenciales lineales (y los generadores congruenciales en general).

A grandes rasgos, un generador de números pseudoaleatorios se basa en aplicar una serie de operaciones aritméticas a un estado inicial (la \emph{semilla}) para obtener el siguiente, y así sucesivamente.

\paragraph{Período de un generador}
Debido a que el estado de un generador es finito, finalmente el mismo se repetirá en algún punto y habrá un ciclo que se repite infinitamente. La cantidad de iteraciones necesaria para que esto ocurra es lo que se denomina el \emph{período del generador}. Según el tipo de generador, sus parámetros y tal vez la semilla empleada puede ser que el mismo sea el máximo soportado por el tamaño de su estado, o que sea menor.\footnote{Lo que necesariamente es igual al tamaño de los valores enteros que genera, por ejemplo el generador Mersenne Twister (MT19937), en su versión original, produce enteros de 32 bits, con un estado interno de 624 palabras de 32 bits (19968 bits en total) y tiene un período de $2^{19937}-1$ \cite{matsumoto1998mersenne}.} Normalmente es deseable que este sea suficientemente grande, idealmente el máximo posible. Sin embargo, vale la pena notar que un período grande no determina que un generador es bueno, debemos verificar que los números que se generan se comportan como si fueran aleatorios.

Recordemos que lo que nos interesa para trabajar con un buen generador de números aleatorios es que la distribución de los números obtenidos tiene que ser uniforme, no deben de haber correlaciones entre los términos de la secuencia, el período debe ser lo más largo posible, y el algoritmo debe ser de ejecución rápida \cite{webfisica2004generacion}.

El problema es saber qué generador de números es mejor, ya que la razón es que si su generador de números aleatorios es bueno, es igualmente probable que aparezca cada posible secuencia de valores \cite{randomorganalysis}. Esto significa que un buen generador de números aleatorios también producirá secuencias que parecen no aleatorias para el ojo humano y que también fallan en cualquier prueba estadística a la que podamos exponerlo.

Es imposible probar definitivamente la aleatoriedad \cite{randomorganalysis}. Una forma de aproximar esto es tomar muchas secuencias de números aleatorios de un generador dado y someterlos a una batería de pruebas estadísticas. A medida que las secuencias pasan más pruebas, aumenta la confianza en la aleatoriedad de los números y también la confianza en el generador. Sin embargo, debido a que esperamos que algunas secuencias no parezcan aleatorias, debemos esperar que algunas de las secuencias fallen al menos en algunas de las pruebas. Sin embargo, si muchas secuencias fallan en las pruebas, deberíamos sospechar.

Hay varias formas de examinar un generador de números aleatorios, las distintas pruebas estadisticas son: análisis visual simple, análisis estadístico de Charmaine Kenny y análisis estadístico de Louise Foley \cite{randomorganalysis}.

\subsection{Tipos de generadores}
\subsubsection{Método de los cuadrados medios}
Como se mencionó anteriormente, este método fue desarrollado por Jonh von Neumann, quien sugirió usar las operaciones aritméticas de una computadora para generar secuencias de números pseudoaleatorios. Con este procedimiento se pueden generar números pseudoaleatorios de 4 dígitos de la siguiente forma \cite{ortiz2018numeros}:
\begin{enumerate}
    \item Se inicia con una semilla de 4 dígitos.
    \item La semilla se eleva al cuadrado, produciendo un número de 8 dígitos (si el resultado tiene menos de 8 dígitos se añaden ceros al inicio). 
    \item Los 4 números del centro serán el siguiente número en la secuencia, y se devuelven como resultado. 
\end{enumerate}
Este generador cae rápidamente en ciclos cortos, por ejemplo, si aparece un cero se propagará por siempre.

A inicios de 1950s se exploró el método y se propusieron mejoras, por ejemplo para evitar caer en cero \cite{ortiz2018numeros}. Metrópolis logró obtener una secuencia de 750,000 números distintos al usar semillas de 38 bits (usaba el sistema binario), además la secuencia de Metrópolis mostraba propiedades deseables. No obstante, el método del valor medio no es considerado un buen método por lo común de los ciclos cortos.

\subsubsection{Generadores congruenciales lineales}
Los generadores congruenciales lineales (GCL) fueron introducidos en 1949 por D.H. Lehmer \cite{ortiz2018numeros}, son muy populares y utilizados incluso hoy en día, en casos donde no se requieran mejores generadores (por ejemplo, no se pueden usar en aplicaciones criptográficas). Tienen la forma:
\begin{equation}
    \label{eq:formula-gcl}
    X_{n+1} = (aX_{n}+c)\mod m
\end{equation}
Donde $a$ es el multiplicador, $m$ el módulo, $c$ el incremento y $X$ la semilla.

Los GCLs continúan siendo utilizados en muchas aplicaciones porque con una elección cuidadosa de los parámetros (la elección de los parámetros determina la calidad del generador) pueden pasar muchas pruebas de aleatoriedad, son rápidos y requieren poca memoria \cite{ortiz2018numeros}.\footnote{Quizás esto no sea tan relevante hoy en día, pero sí que lo es especialmente en dispositivos muy limitados (como pueden ser los microcontroladores).}

Según los parámetros de este generador, existen distintas variantes, cada una con sus propiedades particulares. Algunas de estas variantes son: la sugerida como ejemplo por ANSI C/ISO 9899:1990 (y 1999, 2011, 2017) ($m=2^{31},a=1103515245,c=12345$)\footnote{Aunque en este caso solamente devuelve los 15 bits más significativos de los valores generados}, el implementado por la biblioteca glibc (usado por GCC) que emplea los mismos parámetros que el de ANSI C (sin truncar los bits) \cite{enwiki2022linear}. Otra variante es el infame\cite{knuth1997seminumerical} generador RANDU de Fortran ($m=2^{31},a=65539,c=0$), que ya no se utiliza.

\subsection{Pruebas estadísticas}
\input{hipotesis}
\input{chicuadrado}
\input{poker}
\input{rachas}
\input{monobit}



\section{Análisis de resultados}

Salida del programa:
\begin{verbatim}
+-------------------------------+--------+--------+--------+--------+
| Generadores pseudoaleatorios  | rachas | chi²   | poker  | monobit|
+-------------------------------+--------+--------+--------+--------+
| GCL ANSI C                    | QUIZÁS | QUIZÁS | QUIZÁS | QUIZÁS |
+-------------------------------+--------+--------+--------+--------+
| GCL m=2³² a=10³ c=151         |   NO   | QUIZÁS |   NO   |   NO   |
+-------------------------------+--------+--------+--------+--------+
| MT19937 de Python             | QUIZÁS | QUIZÁS | QUIZÁS | QUIZÁS |
+-------------------------------+--------+--------+--------+--------+
| Cuadrados Medios (4 dígitos)  | QUIZÁS |   NO   |   NO   |   NO   |
+-------------------------------+--------+--------+--------+--------+
| Cuadrados Medios (10 dígitos) | QUIZÁS | QUIZÁS | QUIZÁS |   NO   |
+-------------------------------+--------+--------+--------+--------+
\end{verbatim}

Donde \texttt{"NO"} significa que los datos presentan características que no poseen los generadore ideales de números
aleatorios, y \texttt{"QUIZÁS"} significa que estas características no se encuentran (esto no es suficiente para declarar
la aleatoriedad del método).

\section{Conclusiones}
\input{conclusiones}
